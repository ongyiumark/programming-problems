/*
  We binary search over the level.
  Given a level, we can calculate the maximum power that can be generated by 
    transforming the problem into a bipartite graph.
  Connect cards whose magic number add up to a prime. 
  
  The answer is the maximum independent set, 
    which is a complement of minimum vertex cover,
    which is equivalent to mincut-maxflow. 

  Two numbers add up to a prime only if they have different parity (with exception to 1).
  Connect odd numbers to the source and connect even numbers to sink.
*/
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<int,pair<int,int>> piii;

template <typename T>
using ordered_set = __gnu_pbds::tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
 
const int pMAX = 2e5+5;
const int N = 105;
const int INF = 1e6;
vector<bool> is_composite(pMAX);
vector<int> primes;
vector<pii> q;

struct cards{
  int p, c, l;
};

vector<cards> pcl(N);
int source, sink, n;
int cap[N][N];
int vis[N];

int dfs(int u, int neck) {
  vis[u] = 1;
  if (u == sink) return neck;
  for (int v = 0; v <= n+1; v++) {
    if (vis[v]) continue;

    if (cap[u][v] > 0) {
      q.push_back({u,v});
      int res = dfs(v, min(neck, cap[u][v]));

      if (res != -1) return res;
      q.pop_back();
    }
  }
  return -1;
}

int solve(int max_level) {
  int one_idx = -1;
  int best_one = 0;
  for (int i = 0; i < n; i++) {
    if (pcl[i].c == 1 && pcl[i].l <= max_level && pcl[i].p > best_one) {
      best_one = pcl[i].p;
      one_idx = i;
    }
  }

  int total = 0;
  memset(cap, 0, sizeof cap);
  source = n; sink = n+1;
  for (int i = 0; i < n; i++) {
    if (pcl[i].c%2 == 1) cap[source][i] = cap[i][source] = pcl[i].p;
    else cap[sink][i] = cap[i][sink] = pcl[i].p;  

    if (pcl[i].c == 1 && i != one_idx) continue;
    if (pcl[i].l > max_level) continue;
    total += pcl[i].p;

    for (int j = i+1; j < n; j++) {
      if (pcl[j].c == 1 && j != one_idx) continue;
      if (pcl[j].l > max_level) continue;

      if (!is_composite[pcl[i].c + pcl[j].c]) {
        if (pcl[i].c%2 == 1) cap[i][j] = INF;
        else cap[j][i] = INF;
      }
    }
  }

  int max_flow = 0;
  while (true) {
    memset(vis, 0, sizeof vis);
    int neck = dfs(source, INF);
    if (neck == -1) break;
    for (int i = 0; i < (int)q.size(); i++) {
      auto [u,v] = q[i];
      cap[u][v] -= neck;
      cap[v][u] += neck;
    }
    q.clear();
    max_flow += neck;
  }
  int res = total-max_flow;
  return res;
}

int main(){
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  for (int i = 2; i < pMAX; i++) {
    if (!is_composite[i]) primes.push_back(i);
    for (int j = 0; j < (int)primes.size() && i*primes[j] < pMAX; j++) {
      is_composite[i*primes[j]] = 1;
      if (i%primes[j] == 0) break;
    }
  }

  int k; cin >> n >> k;
  for (int i = 0; i < n; i++) {
    cin >> pcl[i].p >> pcl[i].c >> pcl[i].l;
  }
  
  int lo = 1;
  int hi = n;
  int ans = -1;
  while (lo <= hi) {
    int mid = hi-(hi-lo)/2;
    int max_level = mid;

    int res = solve(max_level);    
    if (res >= k) {
      ans = mid;
      hi = mid-1;
    }
    else lo = mid+1;
  }

  cout << ans << endl;
  return 0;
}
